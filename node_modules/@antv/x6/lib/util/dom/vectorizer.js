"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vectorizer = void 0;
var geometry_1 = require("../../geometry");
var Dom = __importStar(require("./core"));
var Vectorizer = /** @class */ (function () {
    function Vectorizer(elem, attrs, children) {
        if (!elem) {
            throw new TypeError('Invalid element to create vectorizer');
        }
        var node;
        if (Vectorizer.isVector(elem)) {
            node = elem.node;
        }
        else if (typeof elem === 'string') {
            if (elem.toLowerCase() === 'svg') {
                node = Dom.createSvgDocument();
            }
            else if (elem[0] === '<') {
                var svgDoc = Dom.createSvgDocument(elem);
                // only import the first child
                node = document.importNode(svgDoc.firstChild, true);
            }
            else {
                node = document.createElementNS(Dom.ns.svg, elem);
            }
        }
        else {
            node = elem;
        }
        this.node = node;
        if (attrs) {
            this.setAttributes(attrs);
        }
        if (children) {
            this.append(children);
        }
    }
    Object.defineProperty(Vectorizer.prototype, "id", {
        get: function () {
            return this.node.id;
        },
        set: function (id) {
            this.node.id = id;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    Vectorizer.prototype.getTransformToElement = function (target) {
        var ref = Vectorizer.toHTMLElement(target);
        return Dom.getTransformToElement(this.node, ref);
    };
    Vectorizer.prototype.transform = function (matrix, options) {
        if (matrix == null) {
            return Dom.transform(this.node);
        }
        Dom.transform(this.node, matrix, options);
        return this;
    };
    Vectorizer.prototype.translate = function (tx, ty, options) {
        if (ty === void 0) { ty = 0; }
        if (options === void 0) { options = {}; }
        if (tx == null) {
            return Dom.translate(this.node);
        }
        Dom.translate(this.node, tx, ty, options);
        return this;
    };
    Vectorizer.prototype.rotate = function (angle, cx, cy, options) {
        if (options === void 0) { options = {}; }
        if (angle == null) {
            return Dom.rotate(this.node);
        }
        Dom.rotate(this.node, angle, cx, cy, options);
        return this;
    };
    Vectorizer.prototype.scale = function (sx, sy) {
        if (sx == null) {
            return Dom.scale(this.node);
        }
        Dom.scale(this.node, sx, sy);
        return this;
    };
    Vectorizer.prototype.removeAttribute = function (name) {
        Dom.removeAttribute(this.node, name);
        return this;
    };
    Vectorizer.prototype.getAttribute = function (name) {
        return Dom.getAttribute(this.node, name);
    };
    Vectorizer.prototype.setAttribute = function (name, value) {
        Dom.setAttribute(this.node, name, value);
        return this;
    };
    Vectorizer.prototype.setAttributes = function (attrs) {
        Dom.setAttributes(this.node, attrs);
        return this;
    };
    Vectorizer.prototype.attr = function (name, value) {
        if (name == null) {
            return Dom.attr(this.node);
        }
        if (typeof name === 'string' && value === undefined) {
            return Dom.attr(this.node, name);
        }
        if (typeof name === 'object') {
            Dom.attr(this.node, name);
        }
        else {
            Dom.attr(this.node, name, value);
        }
        return this;
    };
    Vectorizer.prototype.svg = function () {
        return this.node instanceof SVGSVGElement
            ? this
            : Vectorizer.createVector(this.node.ownerSVGElement);
    };
    Vectorizer.prototype.defs = function () {
        var context = this.svg() || this;
        var defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) {
            return Vectorizer.createVector(defsNode);
        }
        return Vectorizer.createVector('defs').appendTo(context);
    };
    Vectorizer.prototype.text = function (content, options) {
        if (options === void 0) { options = {}; }
        Dom.text(this.node, content, options);
        return this;
    };
    Vectorizer.prototype.tagName = function () {
        return Dom.tagName(this.node);
    };
    Vectorizer.prototype.clone = function () {
        return Vectorizer.createVector(this.node.cloneNode(true));
    };
    Vectorizer.prototype.remove = function () {
        Dom.remove(this.node);
        return this;
    };
    Vectorizer.prototype.empty = function () {
        Dom.empty(this.node);
        return this;
    };
    Vectorizer.prototype.append = function (elems) {
        Dom.append(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    };
    Vectorizer.prototype.prepend = function (elems) {
        Dom.prepend(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    };
    Vectorizer.prototype.before = function (elems) {
        Dom.before(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    };
    Vectorizer.prototype.appendTo = function (target) {
        Dom.appendTo(this.node, Vectorizer.toHTMLElement(target));
        return this;
    };
    Vectorizer.prototype.findOne = function (selector) {
        var found = Dom.findOne(this.node, selector);
        return found ? Vectorizer.createVector(found) : undefined;
    };
    Vectorizer.prototype.find = function (selector) {
        var vels = [];
        var nodes = Dom.find(this.node, selector);
        if (nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i += 1) {
                vels.push(Vectorizer.createVector(nodes[i]));
            }
        }
        return vels;
    };
    Vectorizer.prototype.findParentByClass = function (className, terminator) {
        var node = Dom.findParentByClass(this.node, className, terminator);
        return node ? Vectorizer.createVector(node) : null;
    };
    Vectorizer.prototype.contains = function (child) {
        return Dom.contains(this.node, child instanceof Vectorizer ? child.node : child);
    };
    Vectorizer.prototype.children = function () {
        var children = this.node.childNodes;
        var vels = [];
        for (var i = 0; i < children.length; i += 1) {
            var currentChild = children[i];
            if (currentChild.nodeType === 1) {
                vels.push(Vectorizer.createVector(children[i]));
            }
        }
        return vels;
    };
    Vectorizer.prototype.index = function () {
        return Dom.index(this.node);
    };
    Vectorizer.prototype.hasClass = function (className) {
        return Dom.hasClass(this.node, className);
    };
    Vectorizer.prototype.addClass = function (className) {
        Dom.addClass(this.node, className);
        return this;
    };
    Vectorizer.prototype.removeClass = function (className) {
        Dom.removeClass(this.node, className);
        return this;
    };
    Vectorizer.prototype.toggleClass = function (className, stateVal) {
        Dom.toggleClass(this.node, className, stateVal);
        return this;
    };
    Vectorizer.prototype.toLocalPoint = function (x, y) {
        return Dom.toLocalPoint(this.node, x, y);
    };
    Vectorizer.prototype.toGeometryShape = function () {
        return Dom.toGeometryShape(this.node);
    };
    Vectorizer.prototype.translateCenterToPoint = function (p) {
        var bbox = this.getBBox({ target: this.svg() });
        var center = bbox.getCenter();
        this.translate(p.x - center.x, p.y - center.y);
        return this;
    };
    Vectorizer.prototype.translateAndAutoOrient = function (position, reference, target) {
        Dom.translateAndAutoOrient(this.node, position, reference, target);
        return this;
    };
    Vectorizer.prototype.animateAlongPath = function (attrs, path) {
        Dom.animateAlongPath(this.node, attrs, path);
        return this;
    };
    /**
     * Normalize this element's d attribute. SVGPathElements without
     * a path data attribute obtain a value of 'M 0 0'.
     */
    Vectorizer.prototype.normalizePath = function () {
        var tagName = this.tagName();
        if (tagName === 'path') {
            this.attr('d', geometry_1.Path.normalize(this.attr('d')));
        }
        return this;
    };
    /**
     * Returns the bounding box of the element after transformations are applied.
     * If `withoutTransformations` is `true`, transformations of the element
     * will not be considered when computing the bounding box. If `target` is
     * specified, bounding box will be computed relatively to the target element.
     */
    Vectorizer.prototype.bbox = function (withoutTransformations, target) {
        return Dom.bbox(this.node, withoutTransformations, target);
    };
    Vectorizer.prototype.getBBox = function (options) {
        if (options === void 0) { options = {}; }
        return Dom.getBBox(this.node, {
            recursive: options.recursive,
            target: Vectorizer.toHTMLElement(options.target),
        });
    };
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    Vectorizer.prototype.sample = function (interval) {
        if (interval === void 0) { interval = 1; }
        if (this.node instanceof SVGPathElement) {
            return Dom.sample(this.node, interval);
        }
        return [];
    };
    Vectorizer.prototype.convertToPath = function () {
        return Vectorizer.createVector(Dom.toPath(this.node));
    };
    Vectorizer.prototype.convertToPathData = function () {
        return Dom.toPathData(this.node);
    };
    return Vectorizer;
}());
exports.Vectorizer = Vectorizer;
(function (Vectorizer) {
    function isVector(o) {
        return o instanceof Vectorizer;
    }
    Vectorizer.isVector = isVector;
    function createVector(elem, attrs, children) {
        return new Vectorizer(elem, attrs, children);
    }
    Vectorizer.createVector = createVector;
    function createVectors(markup) {
        if (markup[0] === '<') {
            var svgDoc = Dom.createSvgDocument(markup);
            var vels = [];
            for (var i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
                var childNode = svgDoc.childNodes[i];
                vels.push(createVector(document.importNode(childNode, true)));
            }
            return vels;
        }
        return [createVector(markup)];
    }
    Vectorizer.createVectors = createVectors;
    function toHTMLElement(elem) {
        if (elem != null) {
            if (isVector(elem)) {
                return elem.node;
            }
            return ((elem.nodeName && elem) || elem[0]);
        }
        return null;
    }
    Vectorizer.toHTMLElement = toHTMLElement;
    function toHTMLElements(elems) {
        if (Array.isArray(elems)) {
            return elems.map(function (elem) { return toHTMLElement(elem); });
        }
        return [toHTMLElement(elems)];
    }
    Vectorizer.toHTMLElements = toHTMLElements;
})(Vectorizer = exports.Vectorizer || (exports.Vectorizer = {}));
exports.Vectorizer = Vectorizer;
//# sourceMappingURL=vectorizer.js.map