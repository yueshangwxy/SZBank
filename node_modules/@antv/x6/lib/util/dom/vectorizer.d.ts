import { Point, Path } from '../../geometry';
import * as Dom from './core';
export declare class Vectorizer {
    node: SVGElement;
    get id(): string;
    set id(id: string);
    constructor(elem: Vectorizer | SVGElement | string, attrs?: Dom.Attributes, children?: Element | Vectorizer | (Element | Vectorizer)[]);
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    getTransformToElement(target: SVGElement | Vectorizer): DOMMatrix;
    /**
     * Returns the current transformation matrix of the Vectorizer element.
     */
    transform(): DOMMatrix;
    /**
     * Applies the provided transformation matrix to the Vectorizer element.
     */
    transform(matrix: DOMMatrix, options?: Dom.TransformOptions): this;
    /**
     * Returns the current translate metadata of the Vectorizer element.
     */
    translate(): Dom.Translation;
    /**
     * Translates the element by `tx` pixels in x axis and `ty` pixels
     * in y axis. `ty` is optional in which case the translation in y axis
     * is considered zero.
     */
    translate(tx: number, ty?: number, options?: Dom.TransformOptions): this;
    /**
     * Returns the current rotate metadata of the Vectorizer element.
     */
    rotate(): Dom.Rotation;
    /**
     * Rotates the element by `angle` degrees. If the optional `cx` and `cy`
     * coordinates are passed, they will be used as an origin for the rotation.
     */
    rotate(angle: number, cx?: number, cy?: number, options?: Dom.TransformOptions): this;
    /**
     * Returns the current scale metadata of the Vectorizer element.
     */
    scale(): Dom.Scale;
    /**
     * Scale the element by `sx` and `sy` factors. If `sy` is not specified,
     * it will be considered the same as `sx`.
     */
    scale(sx: number, sy?: number): this;
    removeAttribute(name: string): this;
    getAttribute(name: string): string | null;
    setAttribute(name: string, value?: string | number | null): this;
    setAttributes(attrs: {
        [attr: string]: string | number | null;
    }): this;
    attr(): {
        [attr: string]: string;
    };
    attr(name: string): string;
    attr(attrs: {
        [attr: string]: string | number | null;
    }): this;
    attr(name: string, value: string | number): this;
    svg(): Vectorizer;
    defs(): Vectorizer;
    text(content: string, options?: Dom.TextOptions): this;
    tagName(): string;
    clone(): Vectorizer;
    remove(): this;
    empty(): this;
    append(elems: Element | DocumentFragment | Vectorizer | (Element | DocumentFragment | Vectorizer)[]): this;
    prepend(elems: Element | DocumentFragment | Vectorizer | (Element | DocumentFragment | Vectorizer)[]): this;
    before(elems: Element | DocumentFragment | Vectorizer | (Element | DocumentFragment | Vectorizer)[]): this;
    appendTo(target: Element | Vectorizer): this;
    findOne(selector: string): Vectorizer | undefined;
    find(selector: string): Vectorizer[];
    findParentByClass(className: string, terminator?: SVGElement): Vectorizer | null;
    contains(child: Element | Vectorizer): boolean;
    children(): Vectorizer[];
    index(): number;
    hasClass(className: string): boolean;
    addClass(className: string): this;
    removeClass(className?: string): this;
    toggleClass(className: string, stateVal?: boolean): this;
    toLocalPoint(x: number, y: number): DOMPoint;
    toGeometryShape(): import("../../geometry").Polyline | import("../../geometry").Rectangle | import("../../geometry").Line | Path | import("../../geometry").Ellipse;
    translateCenterToPoint(p: Point | Point.PointLike): this;
    translateAndAutoOrient(position: Point.PointLike | Point.PointData, reference: Point.PointLike | Point.PointData, target?: SVGElement): this;
    animateAlongPath(attrs: {
        [name: string]: string;
    }, path: SVGPathElement): this;
    /**
     * Normalize this element's d attribute. SVGPathElements without
     * a path data attribute obtain a value of 'M 0 0'.
     */
    normalizePath(): this;
    /**
     * Returns the bounding box of the element after transformations are applied.
     * If `withoutTransformations` is `true`, transformations of the element
     * will not be considered when computing the bounding box. If `target` is
     * specified, bounding box will be computed relatively to the target element.
     */
    bbox(withoutTransformations?: boolean, target?: SVGElement): import("../../geometry").Rectangle;
    getBBox(options?: {
        target?: SVGElement | Vectorizer | null;
        recursive?: boolean;
    }): import("../../geometry").Rectangle;
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    sample(interval?: number): {
        distance: number;
        x: number;
        y: number;
    }[];
    convertToPath(): Vectorizer;
    convertToPathData(): string | null;
}
export declare namespace Vectorizer {
    function isVector(o: any): o is Vectorizer;
    function createVector(elem: Vectorizer | SVGElement | string, attrs?: Dom.Attributes, children?: Element | Vectorizer | (Element | Vectorizer)[]): Vectorizer;
    function createVectors(markup: string): Vectorizer[];
    function toHTMLElement(elem: any): SVGElement | null;
    function toHTMLElements(elems: Element | DocumentFragment | Vectorizer | (Element | DocumentFragment | Vectorizer)[]): SVGElement[];
}
