"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hook = void 0;
var util_1 = require("../util");
var model_1 = require("../model/model");
var cell_1 = require("../view/cell");
var node_1 = require("../view/node");
var edge_1 = require("../view/edge");
var minimap_1 = require("../addon/minimap");
var snapline_1 = require("../addon/snapline");
var scroller_1 = require("../addon/scroller");
var selection_1 = require("../addon/selection");
var clipboard_1 = require("../addon/clipboard");
var transform_1 = require("../addon/transform");
var html_1 = require("../shape/standard/html");
var edge_2 = require("../shape/standard/edge");
var base_1 = require("./base");
var options_1 = require("./options");
var renderer_1 = require("./renderer");
var view_1 = require("./view");
var defs_1 = require("./defs");
var grid_1 = require("./grid");
var coord_1 = require("./coord");
var snapline_2 = require("./snapline");
var scroller_2 = require("./scroller");
var clipboard_2 = require("./clipboard");
var highlight_1 = require("./highlight");
var transform_2 = require("./transform");
var selection_2 = require("./selection");
var background_1 = require("./background");
var history_1 = require("./history");
var minimap_2 = require("./minimap");
var keyboard_1 = require("./keyboard");
var mousewheel_1 = require("./mousewheel");
var print_1 = require("./print");
var format_1 = require("./format");
var Decorator;
(function (Decorator) {
    function hook(nullable, hookName) {
        return function (target, methodName, descriptor) {
            var raw = descriptor.value;
            var name = hookName || methodName;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var hook = this.options[name];
                if (hook != null) {
                    this.getNativeValue = raw.bind.apply(raw, __spreadArrays([this], args));
                    var ret = util_1.FunctionExt.call.apply(util_1.FunctionExt, __spreadArrays([hook, this.graph], args));
                    this.getNativeValue = null;
                    if (ret != null || (nullable === true && ret === null)) {
                        return ret;
                    }
                }
                return raw.call.apply(raw, __spreadArrays([this], args));
            };
        };
    }
    Decorator.hook = hook;
    function after(hookName) {
        return function (target, methodName, descriptor) {
            var raw = descriptor.value;
            var name = hookName || methodName;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var ret = raw.call.apply(raw, __spreadArrays([this], args));
                var hook = this.options[name];
                if (hook != null) {
                    ret = util_1.FunctionExt.call.apply(util_1.FunctionExt, __spreadArrays([hook, this.graph], args)) && ret;
                }
                return ret;
            };
        };
    }
    Decorator.after = after;
})(Decorator || (Decorator = {}));
var Hook = /** @class */ (function (_super) {
    __extends(Hook, _super);
    function Hook() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Hook.prototype.createModel = function () {
        if (this.options.model) {
            return this.options.model;
        }
        var model = new model_1.Model();
        model.graph = this.graph;
        return model;
    };
    Hook.prototype.createView = function () {
        return new view_1.GraphView(this.graph);
    };
    Hook.prototype.createRenderer = function () {
        return new renderer_1.Renderer(this.graph);
    };
    Hook.prototype.createDefsManager = function () {
        return new defs_1.DefsManager(this.graph);
    };
    Hook.prototype.createGridManager = function () {
        return new grid_1.GridManager(this.graph);
    };
    Hook.prototype.createCoordManager = function () {
        return new coord_1.CoordManager(this.graph);
    };
    Hook.prototype.createTransform = function (node, widgetOptions) {
        var options = this.getTransformOptions(node);
        if (options.resizable || options.rotatable) {
            return new transform_1.Transform(__assign(__assign({ node: node, graph: this.graph }, options), widgetOptions));
        }
        return null;
    };
    Hook.prototype.getTransformOptions = function (node) {
        var resizing = options_1.Options.parseOptionGroup(this.graph, node, this.options.resizing);
        var rotating = options_1.Options.parseOptionGroup(this.graph, node, this.options.rotating);
        var transforming = options_1.Options.parseOptionGroup(this.graph, node, this.options.transforming);
        var options = __assign(__assign({}, transforming), { resizable: resizing.enabled, minWidth: resizing.minWidth, maxWidth: resizing.maxWidth, minHeight: resizing.minHeight, maxHeight: resizing.maxHeight, orthogonalResizing: resizing.orthogonal, restrictedResizing: resizing.restricted, autoScrollOnResizing: resizing.autoScroll, preserveAspectRatio: resizing.preserveAspectRatio, rotatable: rotating.enabled, rotateGrid: rotating.grid });
        return options;
    };
    Hook.prototype.createTransformManager = function () {
        return new transform_2.TransformManager(this.graph);
    };
    Hook.prototype.createHighlightManager = function () {
        return new highlight_1.HighlightManager(this.graph);
    };
    Hook.prototype.createBackgroundManager = function () {
        return new background_1.BackgroundManager(this.graph);
    };
    Hook.prototype.createClipboard = function () {
        return new clipboard_1.Clipboard();
    };
    Hook.prototype.createClipboardManager = function () {
        return new clipboard_2.ClipboardManager(this.graph);
    };
    Hook.prototype.createSnapline = function () {
        return new snapline_1.Snapline(__assign({ graph: this.graph }, this.options.snapline));
    };
    Hook.prototype.createSnaplineManager = function () {
        return new snapline_2.SnaplineManager(this.graph);
    };
    Hook.prototype.createSelection = function () {
        return new selection_1.Selection(__assign({ graph: this.graph }, this.options.selecting));
    };
    Hook.prototype.createSelectionManager = function () {
        return new selection_2.SelectionManager(this.graph);
    };
    Hook.prototype.allowRubberband = function (e) {
        return true;
    };
    Hook.prototype.createHistoryManager = function () {
        return new history_1.HistoryManager(__assign({ graph: this.graph }, this.options.history));
    };
    Hook.prototype.createScroller = function () {
        if (this.options.scroller.enabled) {
            return new scroller_1.Scroller(__assign({ graph: this.graph }, this.options.scroller));
        }
        return null;
    };
    Hook.prototype.createScrollerManager = function () {
        return new scroller_2.ScrollerManager(this.graph);
    };
    Hook.prototype.allowPanning = function (e) {
        return true;
    };
    Hook.prototype.createMiniMap = function () {
        var _a = this.options.minimap, enabled = _a.enabled, options = __rest(_a, ["enabled"]);
        if (enabled) {
            var scroller = this.graph.scroller.widget;
            if (scroller == null) {
                throw new Error('Minimap requires scroller be enabled.');
            }
            else {
                return new minimap_1.MiniMap(__assign({ scroller: scroller }, options));
            }
        }
        return null;
    };
    Hook.prototype.createMiniMapManager = function () {
        return new minimap_2.MiniMapManager(this.graph);
    };
    Hook.prototype.createKeyboard = function () {
        return new keyboard_1.Keyboard(__assign({ graph: this.graph }, this.options.keyboard));
    };
    Hook.prototype.createMouseWheel = function () {
        return new mousewheel_1.MouseWheel(__assign({ graph: this.graph }, this.options.mousewheel));
    };
    Hook.prototype.createPrintManager = function () {
        return new print_1.PrintManager(this.graph);
    };
    Hook.prototype.createFormatManager = function () {
        return new format_1.FormatManager(this.graph);
    };
    Hook.prototype.allowMultiEdges = function (edge) {
        var multi = this.options.connecting.multi;
        if (typeof multi !== 'function') {
            return !!multi;
        }
        return util_1.FunctionExt.call(multi, this.graph, {
            edge: edge,
            sourceCell: edge.getSourceCell(),
            targetCell: edge.getTargetCell(),
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
        });
    };
    Hook.prototype.allowDanglingEdge = function (edge) {
        var dangling = this.options.connecting.dangling;
        if (typeof dangling !== 'function') {
            return !!dangling;
        }
        return util_1.FunctionExt.call(dangling, this.graph, {
            edge: edge,
            sourceCell: edge.getSourceCell(),
            targetCell: edge.getTargetCell(),
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
        });
    };
    Hook.prototype.validateEdge = function (edge, type, initialTerminal) {
        if (!this.allowMultiEdges(edge)) {
            var source_1 = edge.getSource();
            var target_1 = edge.getTarget();
            if (source_1.cell && target_1.cell) {
                var sourceCell = edge.getSourceCell();
                if (sourceCell) {
                    var connectedEdges = this.model.getConnectedEdges(sourceCell, {
                        outgoing: true,
                    });
                    var sameEdges = connectedEdges.filter(function (link) {
                        var s = link.getSource();
                        var t = link.getTarget();
                        return (s &&
                            s.cell === source_1.cell &&
                            (!s.port || s.port === source_1.port) &&
                            t &&
                            t.cell === target_1.cell &&
                            (!t.port || t.port === target_1.port));
                    });
                    if (sameEdges.length > 1) {
                        return false;
                    }
                }
            }
        }
        if (!this.allowDanglingEdge(edge)) {
            var sourceId = edge.getSourceCellId();
            var targetId = edge.getTargetCellId();
            if (!(sourceId && targetId)) {
                return false;
            }
        }
        var validate = this.options.connecting.validateEdge;
        if (validate) {
            return util_1.FunctionExt.call(validate, this.graph, {
                edge: edge,
                type: type,
                previous: initialTerminal,
            });
        }
        return true;
    };
    Hook.prototype.validateMagnet = function (cellView, magnet, e) {
        if (magnet.getAttribute('magnet') !== 'passive') {
            var validate = this.options.connecting.validateMagnet;
            if (validate) {
                return util_1.FunctionExt.call(validate, this.graph, {
                    e: e,
                    magnet: magnet,
                    view: cellView,
                    cell: cellView.cell,
                });
            }
            return true;
        }
        return false;
    };
    Hook.prototype.getDefaultEdge = function (sourceView, sourceMagnet) {
        var edge;
        var create = this.options.connecting.createEdge;
        if (create) {
            edge = util_1.FunctionExt.call(create, this.graph, {
                sourceMagnet: sourceMagnet,
                sourceView: sourceView,
                sourceCell: sourceView.cell,
            });
        }
        if (edge == null) {
            edge = new edge_2.Edge();
        }
        return edge;
    };
    Hook.prototype.validateConnection = function (sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView) {
        var validate = this.options.connecting.validateConnection;
        return validate
            ? util_1.FunctionExt.call(validate, this.graph, {
                edgeView: edgeView,
                sourceView: sourceView,
                sourceMagnet: sourceMagnet,
                targetView: targetView,
                targetMagnet: targetMagnet,
                sourceCell: sourceView ? sourceView.cell : null,
                targetCell: targetView ? targetView.cell : null,
                edge: edgeView ? edgeView.cell : null,
                type: terminalType,
            })
            : true;
    };
    Hook.prototype.getRestrictArea = function (view) {
        var restrict = this.options.translating.restrict;
        if (typeof restrict === 'function') {
            return util_1.FunctionExt.call(restrict, this.graph, view);
        }
        if (restrict === true) {
            return this.graph.transform.getGraphArea();
        }
        return restrict || null;
    };
    Hook.prototype.onViewUpdated = function (view, flag, options) {
        if (flag & renderer_1.Renderer.FLAG_INSERT || options.mounting) {
            return;
        }
        this.graph.renderer.requestConnectedEdgesUpdate(view, options);
    };
    Hook.prototype.onViewPostponed = function (view, flag, options) {
        return this.graph.renderer.forcePostponedViewUpdate(view, flag);
    };
    Hook.prototype.getCellView = function (cell) {
        return null;
    };
    Hook.prototype.createCellView = function (cell) {
        var options = { interacting: this.options.interacting };
        var ctor = this.getCellView(cell);
        if (ctor) {
            return new ctor(cell, options);
        }
        var view = cell.view;
        if (view != null && typeof view === 'string') {
            var def = cell_1.CellView.registry.get(view);
            if (def) {
                return new def(cell, options);
            }
            return cell_1.CellView.registry.onNotFound(view);
        }
        if (cell.isNode()) {
            return new node_1.NodeView(cell, options);
        }
        if (cell.isEdge()) {
            return new edge_1.EdgeView(cell, options);
        }
        return null;
    };
    Hook.prototype.getHTMLComponent = function (node) {
        var ret = node.getHTML();
        if (typeof ret === 'string') {
            ret = html_1.HTML.componentRegistry.get(ret) || ret;
        }
        if (typeof ret === 'function') {
            return util_1.FunctionExt.call(ret, this.graph, node);
        }
        return ret;
    };
    Hook.prototype.onEdgeLabelRendered = function (args) { };
    Hook.prototype.onPortRendered = function (args) { };
    Hook.prototype.onToolItemCreated = function (args) { };
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createModel", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createView", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createRenderer", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createDefsManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createGridManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createCoordManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createTransform", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createTransformManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createHighlightManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createBackgroundManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createClipboard", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createClipboardManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createSnapline", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createSnaplineManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createSelection", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createSelectionManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "allowRubberband", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createHistoryManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createScroller", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createScrollerManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "allowPanning", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createMiniMap", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createMiniMapManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createKeyboard", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createMouseWheel", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createPrintManager", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "createFormatManager", null);
    __decorate([
        Decorator.after()
    ], Hook.prototype, "onViewUpdated", null);
    __decorate([
        Decorator.after()
    ], Hook.prototype, "onViewPostponed", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "getCellView", null);
    __decorate([
        Decorator.hook(true)
    ], Hook.prototype, "createCellView", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "getHTMLComponent", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "onEdgeLabelRendered", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "onPortRendered", null);
    __decorate([
        Decorator.hook()
    ], Hook.prototype, "onToolItemCreated", null);
    return Hook;
}(base_1.Base));
exports.Hook = Hook;
//# sourceMappingURL=hook.js.map