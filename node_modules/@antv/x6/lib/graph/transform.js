"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformManager = void 0;
var util_1 = require("../util");
var geometry_1 = require("../geometry");
var base_1 = require("./base");
var TransformManager = /** @class */ (function (_super) {
    __extends(TransformManager, _super);
    function TransformManager() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.widgets = new Map();
        return _this;
    }
    Object.defineProperty(TransformManager.prototype, "container", {
        get: function () {
            return this.graph.view.container;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformManager.prototype, "viewport", {
        get: function () {
            return this.graph.view.viewport;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformManager.prototype, "isSelectionEnabled", {
        get: function () {
            return this.options.selecting.enabled === true;
        },
        enumerable: false,
        configurable: true
    });
    TransformManager.prototype.init = function () {
        this.startListening();
        this.resize();
    };
    TransformManager.prototype.startListening = function () {
        this.graph.on('node:mouseup', this.onNodeMouseUp, this);
        this.graph.on('node:selected', this.onNodeSelected, this);
        this.graph.on('node:unselected', this.onNodeUnSelected, this);
    };
    TransformManager.prototype.stopListening = function () {
        this.graph.off('node:mouseup', this.onNodeMouseUp, this);
        this.graph.off('node:selected', this.onNodeSelected, this);
        this.graph.off('node:unselected', this.onNodeUnSelected, this);
    };
    TransformManager.prototype.onNodeMouseUp = function (_a) {
        var node = _a.node;
        if (!this.isSelectionEnabled) {
            var widget = this.graph.hook.createTransform(node, { clearAll: true });
            if (widget) {
                this.widgets.set(node, widget);
            }
        }
    };
    TransformManager.prototype.onNodeSelected = function (_a) {
        var node = _a.node;
        if (this.isSelectionEnabled) {
            var widget = this.graph.hook.createTransform(node, {
                clearAll: false,
            });
            if (widget) {
                this.widgets.set(node, widget);
            }
        }
    };
    TransformManager.prototype.onNodeUnSelected = function (_a) {
        var node = _a.node;
        if (this.isSelectionEnabled) {
            var widget = this.widgets.get(node);
            if (widget) {
                widget.dispose();
            }
            this.widgets.delete(node);
        }
    };
    /**
     * Returns the current transformation matrix of the graph.
     */
    TransformManager.prototype.getMatrix = function () {
        var transform = this.viewport.getAttribute('transform');
        if (transform !== this.viewportTransformString) {
            // `getCTM`: top-left relative to the SVG element
            // `getScreenCTM`: top-left relative to the document
            this.viewportMatrix = this.viewport.getCTM();
            this.viewportTransformString = transform;
        }
        // Clone the cached current transformation matrix.
        // If no matrix previously stored the identity matrix is returned.
        return util_1.Dom.createSVGMatrix(this.viewportMatrix);
    };
    /**
     * Sets new transformation with the given `matrix`
     */
    TransformManager.prototype.setMatrix = function (matrix) {
        var ctm = util_1.Dom.createSVGMatrix(matrix);
        var transform = util_1.Dom.matrixToTransformString(ctm);
        this.viewport.setAttribute('transform', transform);
        this.viewportMatrix = ctm;
        this.viewportTransformString = transform;
    };
    TransformManager.prototype.resize = function (width, height) {
        var options = this.options;
        var w = width === undefined ? options.width : width;
        var h = height === undefined ? options.height : height;
        options.width = w;
        options.height = h;
        if (typeof w === 'number') {
            w = Math.round(w);
        }
        if (typeof h === 'number') {
            h = Math.round(h);
        }
        this.container.style.width = w == null ? '' : w + "px";
        this.container.style.height = h == null ? '' : h + "px";
        var size = this.getComputedSize();
        this.graph.trigger('resize', __assign({}, size));
        return this;
    };
    TransformManager.prototype.getComputedSize = function () {
        var options = this.options;
        var w = options.width;
        var h = options.height;
        if (!util_1.NumberExt.isNumber(w)) {
            w = this.container.clientWidth;
        }
        if (!util_1.NumberExt.isNumber(h)) {
            h = this.container.clientHeight;
        }
        return { width: w, height: h };
    };
    TransformManager.prototype.getScale = function () {
        return util_1.Dom.matrixToScale(this.getMatrix());
    };
    TransformManager.prototype.scale = function (sx, sy, ox, oy) {
        if (sy === void 0) { sy = sx; }
        if (ox === void 0) { ox = 0; }
        if (oy === void 0) { oy = 0; }
        sx = this.clampScale(sx); // tslint:disable-line
        sy = this.clampScale(sy); // tslint:disable-line
        if (ox || oy) {
            var ts = this.getTranslation();
            var tx = ts.tx - ox * (sx - 1);
            var ty = ts.ty - oy * (sy - 1);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        var matrix = this.getMatrix();
        matrix.a = sx;
        matrix.d = sy;
        this.setMatrix(matrix);
        this.graph.trigger('scale', { sx: sx, sy: sy, ox: ox, oy: oy });
        return this;
    };
    TransformManager.prototype.clampScale = function (scale) {
        var range = this.graph.options.scaling;
        return util_1.NumberExt.clamp(scale, range.min || 0.01, range.max || 16);
    };
    TransformManager.prototype.getRotation = function () {
        return util_1.Dom.matrixToRotation(this.getMatrix());
    };
    TransformManager.prototype.rotate = function (angle, cx, cy) {
        if (cx == null || cy == null) {
            var bbox = util_1.Dom.getBBox(this.graph.view.stage);
            cx = bbox.width / 2; // tslint:disable-line
            cy = bbox.height / 2; // tslint:disable-line
        }
        var ctm = this.getMatrix()
            .translate(cx, cy)
            .rotate(angle)
            .translate(-cx, -cy);
        this.setMatrix(ctm);
        return this;
    };
    TransformManager.prototype.getTranslation = function () {
        return util_1.Dom.matrixToTranslation(this.getMatrix());
    };
    TransformManager.prototype.translate = function (tx, ty) {
        var matrix = this.getMatrix();
        matrix.e = tx || 0;
        matrix.f = ty || 0;
        this.setMatrix(matrix);
        var ts = this.getTranslation();
        var origin = this.options;
        origin.x = ts.tx;
        origin.y = ts.ty;
        this.graph.trigger('translate', __assign({}, ts));
        return this;
    };
    TransformManager.prototype.setOrigin = function (ox, oy) {
        return this.translate(ox || 0, oy || 0);
    };
    TransformManager.prototype.fitToContent = function (gridWidth, gridHeight, padding, options) {
        if (typeof gridWidth === 'object') {
            var opts = gridWidth;
            gridWidth = opts.gridWidth || 1; // tslint:disable-line
            gridHeight = opts.gridHeight || 1; // tslint:disable-line
            padding = opts.padding || 0; // tslint:disable-line
            options = opts; // tslint:disable-line
        }
        else {
            gridWidth = gridWidth || 1; // tslint:disable-line
            gridHeight = gridHeight || 1; // tslint:disable-line
            padding = padding || 0; // tslint:disable-line
            if (options == null) {
                options = {}; // tslint:disable-line
            }
        }
        var paddingValues = util_1.NumberExt.normalizeSides(padding);
        var area = options.contentArea
            ? geometry_1.Rectangle.create(options.contentArea)
            : this.getContentArea(options);
        var scale = this.getScale();
        var translate = this.getTranslation();
        var sx = scale.sx;
        var sy = scale.sy;
        area.x *= sx;
        area.y *= sy;
        area.width *= sx;
        area.height *= sy;
        var width = Math.max(Math.ceil((area.width + area.x) / gridWidth), 1) * gridWidth;
        var height = Math.max(Math.ceil((area.height + area.y) / gridHeight), 1) * gridHeight;
        var tx = 0;
        var ty = 0;
        if ((options.allowNewOrigin === 'negative' && area.x < 0) ||
            (options.allowNewOrigin === 'positive' && area.x >= 0) ||
            options.allowNewOrigin === 'any') {
            tx = Math.ceil(-area.x / gridWidth) * gridWidth;
            tx += paddingValues.left;
            width += tx;
        }
        if ((options.allowNewOrigin === 'negative' && area.y < 0) ||
            (options.allowNewOrigin === 'positive' && area.y >= 0) ||
            options.allowNewOrigin === 'any') {
            ty = Math.ceil(-area.y / gridHeight) * gridHeight;
            ty += paddingValues.top;
            height += ty;
        }
        width += paddingValues.right;
        height += paddingValues.bottom;
        // Make sure the resulting width and height are greater than minimum.
        width = Math.max(width, options.minWidth || 0);
        height = Math.max(height, options.minHeight || 0);
        // Make sure the resulting width and height are lesser than maximum.
        width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
        height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
        var size = this.getComputedSize();
        var sizeChanged = width !== size.width || height !== size.height;
        var originChanged = tx !== translate.tx || ty !== translate.ty;
        // Change the dimensions only if there is a size discrepency or an origin change
        if (originChanged) {
            this.translate(tx, ty);
        }
        if (sizeChanged) {
            this.resize(width, height);
        }
        return new geometry_1.Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
    };
    TransformManager.prototype.scaleContentToFit = function (options) {
        if (options === void 0) { options = {}; }
        var contentBBox;
        // let contentLocalOrigin
        if (options.contentArea) {
            var contentArea = options.contentArea;
            contentBBox = this.graph.localToGraph(contentArea);
            // contentLocalOrigin = Point.create(contentArea)
        }
        else {
            contentBBox = this.getContentBBox(options);
            // contentLocalOrigin = this.graph.graphToLocalPoint(contentBBox)
        }
        if (!contentBBox.width || !contentBBox.height) {
            return;
        }
        var padding = options.padding || 0;
        var minScale = options.minScale || 0;
        var maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
        var minScaleX = options.minScaleX || minScale;
        var maxScaleX = options.maxScaleX || maxScale;
        var minScaleY = options.minScaleY || minScale;
        var maxScaleY = options.maxScaleY || maxScale;
        var fittingBBox;
        if (options.viewportArea) {
            fittingBBox = options.viewportArea;
        }
        else {
            var computedSize = this.getComputedSize();
            var currentTranslate = this.getTranslation();
            fittingBBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height,
            };
        }
        fittingBBox = geometry_1.Rectangle.create(fittingBBox).inflate(-padding);
        var currentScale = this.getScale();
        var newSx = (fittingBBox.width / contentBBox.width) * currentScale.sx;
        var newSy = (fittingBBox.height / contentBBox.height) * currentScale.sy;
        if (options.preserveAspectRatio !== false) {
            newSx = newSy = Math.min(newSx, newSy);
        }
        // snap scale to a grid
        var gridSize = options.scaleGrid;
        if (gridSize) {
            newSx = gridSize * Math.floor(newSx / gridSize);
            newSy = gridSize * Math.floor(newSy / gridSize);
        }
        // scale min/max boundaries
        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
        // const origin = this.options
        // const newOX = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x
        // const newOY = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y
        this.scale(newSx, newSy);
        // this.translate(newOX, newOY)
    };
    TransformManager.prototype.getContentArea = function (options) {
        if (options === void 0) { options = {}; }
        if (options.useCellGeometry) {
            return this.model.getAllCellsBBox() || new geometry_1.Rectangle();
        }
        return util_1.Dom.getBBox(this.graph.view.stage);
    };
    TransformManager.prototype.getContentBBox = function (options) {
        if (options === void 0) { options = {}; }
        return this.graph.localToGraph(this.getContentArea(options));
    };
    TransformManager.prototype.getGraphArea = function () {
        var rect = geometry_1.Rectangle.fromSize(this.getComputedSize());
        return this.graph.graphToLocal(rect);
    };
    TransformManager.prototype.dispose = function () {
        this.widgets.forEach(function (widget) { return widget.dispose(); });
        this.widgets.clear();
        this.stopListening();
    };
    __decorate([
        TransformManager.dispose()
    ], TransformManager.prototype, "dispose", null);
    return TransformManager;
}(base_1.Base));
exports.TransformManager = TransformManager;
//# sourceMappingURL=transform.js.map