"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.er = void 0;
exports.er = function (vertices, options, edgeView) {
    var offset = options.offset || 32;
    var direction = options.direction;
    var sourceBBox = edgeView.sourceBBox;
    var targetBBox = edgeView.targetBBox;
    var sourcePoint = sourceBBox.getCenter();
    var targetPoint = targetBBox.getCenter();
    if (direction == null) {
        var dx = sourcePoint.x - targetPoint.x;
        var dy = sourcePoint.y - targetPoint.y;
        if (Math.abs(dx) > Math.abs(dy)) {
            direction = dx > 0 ? 'R' : 'L';
        }
        else {
            direction = dy > 0 ? 'B' : 'T';
        }
    }
    var coord;
    var dim;
    var factor;
    var horizontal = direction === 'L' || direction === 'R' || direction === 'H';
    if (horizontal) {
        if (targetPoint.y === sourcePoint.y) {
            return __spreadArrays(vertices);
        }
        factor =
            direction === 'L' || (direction === 'H' && targetPoint.x > sourcePoint.x)
                ? 1
                : -1;
        coord = 'x';
        dim = 'width';
    }
    else {
        if (targetPoint.x === sourcePoint.x) {
            return __spreadArrays(vertices);
        }
        factor =
            direction === 'T' || (direction === 'V' && targetPoint.y > sourcePoint.y)
                ? 1
                : -1;
        coord = 'y';
        dim = 'height';
    }
    var source = sourcePoint.clone();
    var target = targetPoint.clone();
    source[coord] += factor * (sourceBBox[dim] / 2 + offset);
    target[coord] -= factor * (targetBBox[dim] / 2 + offset);
    var min = 16;
    if (horizontal) {
        var sourceX = source.x;
        var targetX = target.x;
        var sourceDelta = sourceBBox.width / 2 + min;
        var targetDelta = targetBBox.width / 2 + min;
        if (targetPoint.x > sourcePoint.x) {
            if (targetX <= sourceX) {
                source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
                target.x = Math.min(sourceX, targetPoint.x - targetDelta);
            }
        }
        else {
            if (targetX >= sourceX) {
                source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
                target.x = Math.max(sourceX, targetPoint.x + targetDelta);
            }
        }
    }
    else {
        var sourceY = source.y;
        var targetY = target.y;
        var sourceDelta = sourceBBox.height / 2 + min;
        var targetDelta = targetBBox.height / 2 + min;
        if (targetPoint.y > sourcePoint.y) {
            if (targetY <= sourceY) {
                source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
                target.y = Math.min(sourceY, targetPoint.y - targetDelta);
            }
        }
        else {
            if (targetY >= sourceY) {
                source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
                target.y = Math.max(sourceY, targetPoint.y + targetDelta);
            }
        }
    }
    return __spreadArrays([source.toJSON()], vertices, [target.toJSON()]);
};
//# sourceMappingURL=er.js.map