var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { FunctionExt } from '../util';
import { Model } from '../model/model';
import { CellView } from '../view/cell';
import { NodeView } from '../view/node';
import { EdgeView } from '../view/edge';
import { MiniMap } from '../addon/minimap';
import { Snapline } from '../addon/snapline';
import { Scroller } from '../addon/scroller';
import { Selection } from '../addon/selection';
import { Clipboard } from '../addon/clipboard';
import { Transform } from '../addon/transform';
import { HTML } from '../shape/standard/html';
import { Edge as StandardEdge } from '../shape/standard/edge';
import { Base } from './base';
import { Options } from './options';
import { Renderer } from './renderer';
import { GraphView } from './view';
import { DefsManager } from './defs';
import { GridManager } from './grid';
import { CoordManager } from './coord';
import { SnaplineManager } from './snapline';
import { ScrollerManager } from './scroller';
import { ClipboardManager } from './clipboard';
import { HighlightManager } from './highlight';
import { TransformManager } from './transform';
import { SelectionManager } from './selection';
import { BackgroundManager } from './background';
import { HistoryManager } from './history';
import { MiniMapManager } from './minimap';
import { Keyboard } from './keyboard';
import { MouseWheel } from './mousewheel';
import { PrintManager } from './print';
import { FormatManager } from './format';
var Decorator;
(function (Decorator) {
    function hook(nullable, hookName) {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const name = hookName || methodName;
            descriptor.value = function (...args) {
                const hook = this.options[name];
                if (hook != null) {
                    this.getNativeValue = raw.bind(this, ...args);
                    const ret = FunctionExt.call(hook, this.graph, ...args);
                    this.getNativeValue = null;
                    if (ret != null || (nullable === true && ret === null)) {
                        return ret;
                    }
                }
                return raw.call(this, ...args);
            };
        };
    }
    Decorator.hook = hook;
    function after(hookName) {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const name = hookName || methodName;
            descriptor.value = function (...args) {
                let ret = raw.call(this, ...args);
                const hook = this.options[name];
                if (hook != null) {
                    ret = FunctionExt.call(hook, this.graph, ...args) && ret;
                }
                return ret;
            };
        };
    }
    Decorator.after = after;
})(Decorator || (Decorator = {}));
export class Hook extends Base {
    createModel() {
        if (this.options.model) {
            return this.options.model;
        }
        const model = new Model();
        model.graph = this.graph;
        return model;
    }
    createView() {
        return new GraphView(this.graph);
    }
    createRenderer() {
        return new Renderer(this.graph);
    }
    createDefsManager() {
        return new DefsManager(this.graph);
    }
    createGridManager() {
        return new GridManager(this.graph);
    }
    createCoordManager() {
        return new CoordManager(this.graph);
    }
    createTransform(node, widgetOptions) {
        const options = this.getTransformOptions(node);
        if (options.resizable || options.rotatable) {
            return new Transform(Object.assign(Object.assign({ node, graph: this.graph }, options), widgetOptions));
        }
        return null;
    }
    getTransformOptions(node) {
        const resizing = Options.parseOptionGroup(this.graph, node, this.options.resizing);
        const rotating = Options.parseOptionGroup(this.graph, node, this.options.rotating);
        const transforming = Options.parseOptionGroup(this.graph, node, this.options.transforming);
        const options = Object.assign(Object.assign({}, transforming), { resizable: resizing.enabled, minWidth: resizing.minWidth, maxWidth: resizing.maxWidth, minHeight: resizing.minHeight, maxHeight: resizing.maxHeight, orthogonalResizing: resizing.orthogonal, restrictedResizing: resizing.restricted, autoScrollOnResizing: resizing.autoScroll, preserveAspectRatio: resizing.preserveAspectRatio, rotatable: rotating.enabled, rotateGrid: rotating.grid });
        return options;
    }
    createTransformManager() {
        return new TransformManager(this.graph);
    }
    createHighlightManager() {
        return new HighlightManager(this.graph);
    }
    createBackgroundManager() {
        return new BackgroundManager(this.graph);
    }
    createClipboard() {
        return new Clipboard();
    }
    createClipboardManager() {
        return new ClipboardManager(this.graph);
    }
    createSnapline() {
        return new Snapline(Object.assign({ graph: this.graph }, this.options.snapline));
    }
    createSnaplineManager() {
        return new SnaplineManager(this.graph);
    }
    createSelection() {
        return new Selection(Object.assign({ graph: this.graph }, this.options.selecting));
    }
    createSelectionManager() {
        return new SelectionManager(this.graph);
    }
    allowRubberband(e) {
        return true;
    }
    createHistoryManager() {
        return new HistoryManager(Object.assign({ graph: this.graph }, this.options.history));
    }
    createScroller() {
        if (this.options.scroller.enabled) {
            return new Scroller(Object.assign({ graph: this.graph }, this.options.scroller));
        }
        return null;
    }
    createScrollerManager() {
        return new ScrollerManager(this.graph);
    }
    allowPanning(e) {
        return true;
    }
    createMiniMap() {
        const _a = this.options.minimap, { enabled } = _a, options = __rest(_a, ["enabled"]);
        if (enabled) {
            const scroller = this.graph.scroller.widget;
            if (scroller == null) {
                throw new Error('Minimap requires scroller be enabled.');
            }
            else {
                return new MiniMap(Object.assign({ scroller }, options));
            }
        }
        return null;
    }
    createMiniMapManager() {
        return new MiniMapManager(this.graph);
    }
    createKeyboard() {
        return new Keyboard(Object.assign({ graph: this.graph }, this.options.keyboard));
    }
    createMouseWheel() {
        return new MouseWheel(Object.assign({ graph: this.graph }, this.options.mousewheel));
    }
    createPrintManager() {
        return new PrintManager(this.graph);
    }
    createFormatManager() {
        return new FormatManager(this.graph);
    }
    allowMultiEdges(edge) {
        const multi = this.options.connecting.multi;
        if (typeof multi !== 'function') {
            return !!multi;
        }
        return FunctionExt.call(multi, this.graph, {
            edge,
            sourceCell: edge.getSourceCell(),
            targetCell: edge.getTargetCell(),
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
        });
    }
    allowDanglingEdge(edge) {
        const dangling = this.options.connecting.dangling;
        if (typeof dangling !== 'function') {
            return !!dangling;
        }
        return FunctionExt.call(dangling, this.graph, {
            edge,
            sourceCell: edge.getSourceCell(),
            targetCell: edge.getTargetCell(),
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
        });
    }
    validateEdge(edge, type, initialTerminal) {
        if (!this.allowMultiEdges(edge)) {
            const source = edge.getSource();
            const target = edge.getTarget();
            if (source.cell && target.cell) {
                const sourceCell = edge.getSourceCell();
                if (sourceCell) {
                    const connectedEdges = this.model.getConnectedEdges(sourceCell, {
                        outgoing: true,
                    });
                    const sameEdges = connectedEdges.filter((link) => {
                        const s = link.getSource();
                        const t = link.getTarget();
                        return (s &&
                            s.cell === source.cell &&
                            (!s.port || s.port === source.port) &&
                            t &&
                            t.cell === target.cell &&
                            (!t.port || t.port === target.port));
                    });
                    if (sameEdges.length > 1) {
                        return false;
                    }
                }
            }
        }
        if (!this.allowDanglingEdge(edge)) {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (!(sourceId && targetId)) {
                return false;
            }
        }
        const validate = this.options.connecting.validateEdge;
        if (validate) {
            return FunctionExt.call(validate, this.graph, {
                edge,
                type,
                previous: initialTerminal,
            });
        }
        return true;
    }
    validateMagnet(cellView, magnet, e) {
        if (magnet.getAttribute('magnet') !== 'passive') {
            const validate = this.options.connecting.validateMagnet;
            if (validate) {
                return FunctionExt.call(validate, this.graph, {
                    e,
                    magnet,
                    view: cellView,
                    cell: cellView.cell,
                });
            }
            return true;
        }
        return false;
    }
    getDefaultEdge(sourceView, sourceMagnet) {
        let edge;
        const create = this.options.connecting.createEdge;
        if (create) {
            edge = FunctionExt.call(create, this.graph, {
                sourceMagnet,
                sourceView,
                sourceCell: sourceView.cell,
            });
        }
        if (edge == null) {
            edge = new StandardEdge();
        }
        return edge;
    }
    validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView) {
        const validate = this.options.connecting.validateConnection;
        return validate
            ? FunctionExt.call(validate, this.graph, {
                edgeView,
                sourceView,
                sourceMagnet,
                targetView,
                targetMagnet,
                sourceCell: sourceView ? sourceView.cell : null,
                targetCell: targetView ? targetView.cell : null,
                edge: edgeView ? edgeView.cell : null,
                type: terminalType,
            })
            : true;
    }
    getRestrictArea(view) {
        const restrict = this.options.translating.restrict;
        if (typeof restrict === 'function') {
            return FunctionExt.call(restrict, this.graph, view);
        }
        if (restrict === true) {
            return this.graph.transform.getGraphArea();
        }
        return restrict || null;
    }
    onViewUpdated(view, flag, options) {
        if (flag & Renderer.FLAG_INSERT || options.mounting) {
            return;
        }
        this.graph.renderer.requestConnectedEdgesUpdate(view, options);
    }
    onViewPostponed(view, flag, options) {
        return this.graph.renderer.forcePostponedViewUpdate(view, flag);
    }
    getCellView(cell) {
        return null;
    }
    createCellView(cell) {
        const options = { interacting: this.options.interacting };
        const ctor = this.getCellView(cell);
        if (ctor) {
            return new ctor(cell, options);
        }
        const view = cell.view;
        if (view != null && typeof view === 'string') {
            const def = CellView.registry.get(view);
            if (def) {
                return new def(cell, options);
            }
            return CellView.registry.onNotFound(view);
        }
        if (cell.isNode()) {
            return new NodeView(cell, options);
        }
        if (cell.isEdge()) {
            return new EdgeView(cell, options);
        }
        return null;
    }
    getHTMLComponent(node) {
        let ret = node.getHTML();
        if (typeof ret === 'string') {
            ret = HTML.componentRegistry.get(ret) || ret;
        }
        if (typeof ret === 'function') {
            return FunctionExt.call(ret, this.graph, node);
        }
        return ret;
    }
    onEdgeLabelRendered(args) { }
    onPortRendered(args) { }
    onToolItemCreated(args) { }
}
__decorate([
    Decorator.hook()
], Hook.prototype, "createModel", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createView", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createRenderer", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createDefsManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createGridManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createCoordManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createTransform", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createTransformManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createHighlightManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createBackgroundManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createClipboard", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createClipboardManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createSnapline", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createSnaplineManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createSelection", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createSelectionManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "allowRubberband", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createHistoryManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createScroller", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createScrollerManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "allowPanning", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createMiniMap", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createMiniMapManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createKeyboard", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createMouseWheel", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createPrintManager", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "createFormatManager", null);
__decorate([
    Decorator.after()
], Hook.prototype, "onViewUpdated", null);
__decorate([
    Decorator.after()
], Hook.prototype, "onViewPostponed", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "getCellView", null);
__decorate([
    Decorator.hook(true)
], Hook.prototype, "createCellView", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "getHTMLComponent", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "onEdgeLabelRendered", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "onPortRendered", null);
__decorate([
    Decorator.hook()
], Hook.prototype, "onToolItemCreated", null);
//# sourceMappingURL=hook.js.map