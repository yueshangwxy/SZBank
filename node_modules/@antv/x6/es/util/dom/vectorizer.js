import { Path } from '../../geometry';
import * as Dom from './core';
export class Vectorizer {
    constructor(elem, attrs, children) {
        if (!elem) {
            throw new TypeError('Invalid element to create vectorizer');
        }
        let node;
        if (Vectorizer.isVector(elem)) {
            node = elem.node;
        }
        else if (typeof elem === 'string') {
            if (elem.toLowerCase() === 'svg') {
                node = Dom.createSvgDocument();
            }
            else if (elem[0] === '<') {
                const svgDoc = Dom.createSvgDocument(elem);
                // only import the first child
                node = document.importNode(svgDoc.firstChild, true);
            }
            else {
                node = document.createElementNS(Dom.ns.svg, elem);
            }
        }
        else {
            node = elem;
        }
        this.node = node;
        if (attrs) {
            this.setAttributes(attrs);
        }
        if (children) {
            this.append(children);
        }
    }
    get id() {
        return this.node.id;
    }
    set id(id) {
        this.node.id = id;
    }
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    getTransformToElement(target) {
        const ref = Vectorizer.toHTMLElement(target);
        return Dom.getTransformToElement(this.node, ref);
    }
    transform(matrix, options) {
        if (matrix == null) {
            return Dom.transform(this.node);
        }
        Dom.transform(this.node, matrix, options);
        return this;
    }
    translate(tx, ty = 0, options = {}) {
        if (tx == null) {
            return Dom.translate(this.node);
        }
        Dom.translate(this.node, tx, ty, options);
        return this;
    }
    rotate(angle, cx, cy, options = {}) {
        if (angle == null) {
            return Dom.rotate(this.node);
        }
        Dom.rotate(this.node, angle, cx, cy, options);
        return this;
    }
    scale(sx, sy) {
        if (sx == null) {
            return Dom.scale(this.node);
        }
        Dom.scale(this.node, sx, sy);
        return this;
    }
    removeAttribute(name) {
        Dom.removeAttribute(this.node, name);
        return this;
    }
    getAttribute(name) {
        return Dom.getAttribute(this.node, name);
    }
    setAttribute(name, value) {
        Dom.setAttribute(this.node, name, value);
        return this;
    }
    setAttributes(attrs) {
        Dom.setAttributes(this.node, attrs);
        return this;
    }
    attr(name, value) {
        if (name == null) {
            return Dom.attr(this.node);
        }
        if (typeof name === 'string' && value === undefined) {
            return Dom.attr(this.node, name);
        }
        if (typeof name === 'object') {
            Dom.attr(this.node, name);
        }
        else {
            Dom.attr(this.node, name, value);
        }
        return this;
    }
    svg() {
        return this.node instanceof SVGSVGElement
            ? this
            : Vectorizer.createVector(this.node.ownerSVGElement);
    }
    defs() {
        const context = this.svg() || this;
        const defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) {
            return Vectorizer.createVector(defsNode);
        }
        return Vectorizer.createVector('defs').appendTo(context);
    }
    text(content, options = {}) {
        Dom.text(this.node, content, options);
        return this;
    }
    tagName() {
        return Dom.tagName(this.node);
    }
    clone() {
        return Vectorizer.createVector(this.node.cloneNode(true));
    }
    remove() {
        Dom.remove(this.node);
        return this;
    }
    empty() {
        Dom.empty(this.node);
        return this;
    }
    append(elems) {
        Dom.append(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    }
    prepend(elems) {
        Dom.prepend(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    }
    before(elems) {
        Dom.before(this.node, Vectorizer.toHTMLElements(elems));
        return this;
    }
    appendTo(target) {
        Dom.appendTo(this.node, Vectorizer.toHTMLElement(target));
        return this;
    }
    findOne(selector) {
        const found = Dom.findOne(this.node, selector);
        return found ? Vectorizer.createVector(found) : undefined;
    }
    find(selector) {
        const vels = [];
        const nodes = Dom.find(this.node, selector);
        if (nodes) {
            for (let i = 0, ii = nodes.length; i < ii; i += 1) {
                vels.push(Vectorizer.createVector(nodes[i]));
            }
        }
        return vels;
    }
    findParentByClass(className, terminator) {
        const node = Dom.findParentByClass(this.node, className, terminator);
        return node ? Vectorizer.createVector(node) : null;
    }
    contains(child) {
        return Dom.contains(this.node, child instanceof Vectorizer ? child.node : child);
    }
    children() {
        const children = this.node.childNodes;
        const vels = [];
        for (let i = 0; i < children.length; i += 1) {
            const currentChild = children[i];
            if (currentChild.nodeType === 1) {
                vels.push(Vectorizer.createVector(children[i]));
            }
        }
        return vels;
    }
    index() {
        return Dom.index(this.node);
    }
    hasClass(className) {
        return Dom.hasClass(this.node, className);
    }
    addClass(className) {
        Dom.addClass(this.node, className);
        return this;
    }
    removeClass(className) {
        Dom.removeClass(this.node, className);
        return this;
    }
    toggleClass(className, stateVal) {
        Dom.toggleClass(this.node, className, stateVal);
        return this;
    }
    toLocalPoint(x, y) {
        return Dom.toLocalPoint(this.node, x, y);
    }
    toGeometryShape() {
        return Dom.toGeometryShape(this.node);
    }
    translateCenterToPoint(p) {
        const bbox = this.getBBox({ target: this.svg() });
        const center = bbox.getCenter();
        this.translate(p.x - center.x, p.y - center.y);
        return this;
    }
    translateAndAutoOrient(position, reference, target) {
        Dom.translateAndAutoOrient(this.node, position, reference, target);
        return this;
    }
    animateAlongPath(attrs, path) {
        Dom.animateAlongPath(this.node, attrs, path);
        return this;
    }
    /**
     * Normalize this element's d attribute. SVGPathElements without
     * a path data attribute obtain a value of 'M 0 0'.
     */
    normalizePath() {
        const tagName = this.tagName();
        if (tagName === 'path') {
            this.attr('d', Path.normalize(this.attr('d')));
        }
        return this;
    }
    /**
     * Returns the bounding box of the element after transformations are applied.
     * If `withoutTransformations` is `true`, transformations of the element
     * will not be considered when computing the bounding box. If `target` is
     * specified, bounding box will be computed relatively to the target element.
     */
    bbox(withoutTransformations, target) {
        return Dom.bbox(this.node, withoutTransformations, target);
    }
    getBBox(options = {}) {
        return Dom.getBBox(this.node, {
            recursive: options.recursive,
            target: Vectorizer.toHTMLElement(options.target),
        });
    }
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    sample(interval = 1) {
        if (this.node instanceof SVGPathElement) {
            return Dom.sample(this.node, interval);
        }
        return [];
    }
    convertToPath() {
        return Vectorizer.createVector(Dom.toPath(this.node));
    }
    convertToPathData() {
        return Dom.toPathData(this.node);
    }
}
(function (Vectorizer) {
    function isVector(o) {
        return o instanceof Vectorizer;
    }
    Vectorizer.isVector = isVector;
    function createVector(elem, attrs, children) {
        return new Vectorizer(elem, attrs, children);
    }
    Vectorizer.createVector = createVector;
    function createVectors(markup) {
        if (markup[0] === '<') {
            const svgDoc = Dom.createSvgDocument(markup);
            const vels = [];
            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
                const childNode = svgDoc.childNodes[i];
                vels.push(createVector(document.importNode(childNode, true)));
            }
            return vels;
        }
        return [createVector(markup)];
    }
    Vectorizer.createVectors = createVectors;
    function toHTMLElement(elem) {
        if (elem != null) {
            if (isVector(elem)) {
                return elem.node;
            }
            return ((elem.nodeName && elem) || elem[0]);
        }
        return null;
    }
    Vectorizer.toHTMLElement = toHTMLElement;
    function toHTMLElements(elems) {
        if (Array.isArray(elems)) {
            return elems.map((elem) => toHTMLElement(elem));
        }
        return [toHTMLElement(elems)];
    }
    Vectorizer.toHTMLElements = toHTMLElements;
})(Vectorizer || (Vectorizer = {}));
//# sourceMappingURL=vectorizer.js.map